# 点赞接口设计
## 业务场景分析
抖音的场景大部分是读多写少，但点赞场景除外，抖音的点赞场景读写量的差距并不是很大（可能用户每刷2-3个视频就会对该视频进行点赞），
所以抖音的点赞场景需要有些更加特殊的处理方式。并且点赞业务对于数据实时性要求不是很高，
就是假设视频A这段时间被额外点赞了1K次，但用户只能看到500次，对于该业务场景来说其差距并不是十分关键，
用户可以容忍此类差距，因此针对点赞的业务场景，实现缓存-数据库的最终的一致性方案。

## 数据库表设计
点赞对应的数据表可以查看数据库表设计文档，此处专门针对软删除项进行讲解。
在真实业务场景中，可能用户的会有点赞的误操作，例如当用户不小心双击的时候，就会点赞他一个不想点赞的视频，
或者针对一个用户想点赞的视频但用户不小心取消了点赞，在业务中这样的误操作场景让软删除项变得十分有必要。
针对用户点赞，如果数据库中已经存在(userId,videoId)的二元组，那么只需将软删除项设置为1；对于用户取消点赞，
也是针对该二元组，将该二元组的软删除项设置为0。由于

然后在Dao层执行一个定时策略，定期将数据库项中软删除项删除，防止占用过多的存储空间。

## 点赞不同消息的存储模式分析
### 视频点赞数
视频点赞数目是项目中需要进行频繁更改的条目，因此对于视频点赞数的变化不会直接写入数据库中，而是在redis中
进行存储，当点赞微服务被调用的次数较少（不频繁时，则再将视频点赞数通过事务持久化入数据库中）。一个视频的
被点赞数在redis中使用的数据结构为String，通过Incr/Decr两个操作对该键值进行修改。

Redis的Incr,Decr操作是通过incrDecrCommand进行实现的，该方法主要完成了以下的任务：
- 1、先拿到键值对象。
- 2、拿到原来的值。
- 3、判断接下来的递增是否超过最大值或者最小值。
- 4、判断新值是否为共享数据，如果是则直接共享值，不是则新建一个值。
- 5、标记键已被修改
- 6、通知事件
- 7、响应新的值

### 用户点赞列表

对于用户的点赞列表，目前是采用了Redis中的List数据结构，然后当用户点赞一个新视频，就把新的videoId插入到
List的头部。

**（未实现）对于大Key的处理**

当用户数目大量增加，用户点赞的视频数也大量增加，那么此时可以在缓存中缓存前16个视频（一个页面），当大量用户翻动
时，进行Key的分批处理。

## 缓存-数据库最终一致性策略设计
首先，本地两台机器上运行两个点赞微服务，然后在APP层进行ETCD的服务注册与负载均衡策略。然后在Gateway层进行计时，
当过去一分钟内点赞接口的被调用次数少于1w次，那么对Service层运行的微服务主节点调用一次消息同步，
在service层中通过RPC通信的方式，使用Raft协议进行binlog的同步，最终写入数据库并删除缓存。