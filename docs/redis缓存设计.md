# 项目缓存设计
项目缓存redis是项目中的核心组件，多个读写操作都使用redis，提高读写效率，减轻数据库压力，并减少请求的耗时，
极大提升用户的体验。

## 需求分析
大部分场景都是读多写少，增加缓存使得大部分请求不会访问到数据库，从缓存中直接获取数据返回，减少了数据库压力。

针对不同场景实现的缓存-数据库一致性策略可于/designs目录下进行查看。

[点赞]()


## 持久化策略
由于在真实的业务场景中，我们无法保证一个redis服务器/集群永远保持工作，因此我们需要对redis进行一些持久化
策略的选型：在项目中我们针对redis持久化策略采用混合持久化。

**为什么采用混合持久化**

RDB 优点是数据恢复速度快，但是快照的频率不好把握。频率太低，丢失的数据就会比较多，频率太高，就会影响性能。

AOF 优点是丢失数据少，但是数据恢复不快。

为了集成了两者的优点， Redis 4.0 提出了混合使用 AOF 日志和内存快照，也叫混合持久化，既保证了 Redis 重启速度，又降低数据丢失风险。

混合持久化工作在 AOF 日志重写过程，当开启了混合持久化时，在 AOF 重写日志时，fork 出来的重写子进程会先将与主线程共享的内存数据以 RDB 方式写入到 AOF 文件，然后主线程处理的操作命令会被记录在重写缓冲区里，重写缓冲区里的增量命令会以 AOF 方式写入到 AOF 文件，写入完成后通知主进程将新的含有 RDB 格式和 AOF 格式的 AOF 文件替换旧的的 AOF 文件。

也就是说，使用了混合持久化，AOF 文件的前半部分是 RDB 格式的全量数据，后半部分是 AOF 格式的增量数据。

其优点在于：混合持久化开头的RDB格式保证了redis可以更快启动，并结合AOF的优点，有效降低了大量数据丢失的风险。

## Redis缓存整体设计说明
- 使用了redislabs/rebloom作为镜像，该镜像集成了bloom过滤器的插件，在项目中也有使用Bloom过滤器。
- 使用的客户端为go-redis，方便配置连接池 
### 缓存雪崩
```
通常我们为了保证缓存中的数据与数据库中的数据一致性，会给 Redis 里的数据设置过期时间，
当缓存数据过期后，用户访问的数据如果不在缓存里，业务系统需要重新生成缓存，因此就会访问数据库，
并将数据更新到 Redis 里，这样后续请求都可以直接命中缓存。

那么，当大量缓存数据在同一时间过期（失效）或者 Redis 故障宕机时，如果此时有大量的用户请求，
都无法在 Redis 中处理，于是全部请求都直接访问数据库，从而导致数据库的压力骤增，严重的会造成数据库宕机，
从而形成一系列连锁反应，造成整个系统崩溃，这就是缓存雪崩的问题。
```
针对缓存雪崩问题，在项目中采用了均匀设置过期时间的策略，在给缓存数据设置过期时间为24小时的基础上，
将这些数据的过期时间增加一个随机的4小时内的随机量，保证数据不会在同一时间同时过期。
### 缓存击穿
```
项目中通常会有几个数据会被频繁访问（例如大V的主页，一段时间内特别火爆的视频），
如果缓存中的某个热点数据过期了，此时大量的请求访问了该热点数据，就无法从缓存中读取，
直接访问数据库，数据库很容易就被高并发的请求冲垮，这就是缓存击穿的问题。
```
针对缓存击穿的问题，项目中采取的策略是，当缓存中的数据被命中时，延长其持续时间4小时，这样保证了热点数据
永不过期，也防止当视频不那么热门时占用过大的内存空间。
### 缓存穿透
```
当发生缓存雪崩或击穿时，数据库中还是保存了应用要访问的数据，一旦缓存恢复相对应的数据，就可以减轻数据库的压力，而缓存穿透就不一样了。

当用户访问的数据，既不在缓存中，也不在数据库中（例如黑客故意访问不存在的视频进行攻击，或者大V发表了视频之后进行删除），
导致请求在访问缓存时，发现缓存缺失，再去访问数据库时，发现数据库中也没有要访问的数据，
没办法构建缓存数据，来服务后续的请求。那么当有大量这样的请求到来时，数据库的压力骤增，这就是缓存穿透的问题。
```
针对缓存穿透的问题，项目中采用了布隆过滤器和缓存空值的方式。

### 突发热点数据的处理
```
当有一个视频突然变得热门（例如当某个大V突然发表一个视频，或者某个视频突然变得十分热门），
此时可能缓存中还不存在该视频，但同时有大量的请求（点赞、评论等）过来，这种情况应该如何进行处理。
```
使用双重检测锁DCL（分布式锁），在golang中没有类似于Java中提供的Redisson标准库包。
因此自己在项目中搭建了一个简单的分布式锁。 当大量请求打到一个缓存中不存在的视频时，首先需要重建缓存，
此时最先拿到双重检测锁DCL的那个协程进行缓存重建， 其余请求就能够直接从缓存中获取数据，
并且可以用TryLock的方式避免大量协程长时间等待。

### 手撸分布式锁
```
上文提到Golang中没有实现类似于Java中的Redisson,因此自己手写一个分布式锁
```
详情可见[distributedLock](https://github.com/warthecatalyst/simple-douyin-backend/blob/main/internal/utils/redisUtils/distributedLock.go)


